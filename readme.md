

# **Introduction**

The project is a restaurant management system API that allows restaurant owners to manage their menus, orders, and employees. The API is built using gRPC, a high-performance, open-source framework for building APIs. The project uses a layered architecture that separates concerns and ensures scalability and maintainability.

The core of the system is the database, which is implemented using PostgreSQL and managed using the SQLC tool to generate Go code for interacting with the database. The application layer is responsible for handling business logic and uses the database layer for data persistence.

The project includes several key features, including the ability to create and manage menus, track inventory, manage employee schedules, and process customer orders. The project is designed to be extensible, allowing new features to be added easily and without disrupting existing functionality.

The project is built using Go, a statically typed, compiled programming language known for its performance and scalability. The project uses several popular Go libraries, including gRPC, protobuf, and SQLC, to simplify development and ensure high-quality code.



* is to provide a comprehensive guide for developers who are new to the project, explaining the architecture, design choices, and how to work with the codebase. It should serve as a reference for developers to understand the project's functionality and how to add new features or modify existing ones. The documentation should also provide an overview of the API endpoints and their functionality.


# **Architecture**

	The project follows a clean architecture design pattern, where the code is organized into multiple layers. The main layers are:



* `app`: This layer contains the main business logic of the application. It is organized into modules, where each module represents a separate domain of the application. Each module has its own set of sub-packages, including `factory`, `repo`, and `usecase`, which are responsible for creating domain objects, accessing and persisting data, and executing use cases, respectively.
* `pkg`: This layer contains packages that are shared across the application. It includes sub-packages for authentication, database access, gRPC API implementation, and validation, among others.
* `sqlc`: This package contains SQL queries defined as `.sql` files, which are used to generate Go code for database access.
* `pb`: This package contains the generated Go code from the protobuf files defined in the `pkg/proto` directory.
* `util`: This package contains utility functions used across the application.
* `validator`: This package contains custom validation rules used to validate incoming requests.

The project uses gRPC as the primary API for communication with clients, although HTTP endpoints are also generated by the `buf build` command. The project uses the `sqlc` tool for generating Go code from SQL queries, which are used to interact with the database.

The project also uses a `Makefile` to automate various tasks, such as building and running the application, running tests, and generating code.

The `app.env` file contains environment variables used by the application, such as the database connection string and the server port number.


# **Installation**



* Clone the `mln_rms_api` repository from Github: \
```
git clone https://github.com/darwishdev/obd_api.git
```
* Update the `app.env` and `test.env` files to include the necessary database credentials and running ports. The `test.env` file should include separate testing database credentials.
    ```
    ENVIRONMENT=development
    DB_DRIVER=postgres
    DB_USER=dev
    DB_NAME=mln_rms
    DB_HOST=localhost
    DB_PASSWORD=secret
    DB_PORT=5432
    GRPC_PORT=9090
    DB_SOURCE=${DB_DRIVER}://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}?sslmode=disable
    MIGRATION_URL=file://db/migration
    GRPC_SERVER_ADDRESS=0.0.0.0:${GRPC_PORT}
    TOKEN_SYMMETRIC_KEY=12345678901234567890123456789012
    ACCESS_TOKEN_DURATION=15m
    REFRESH_TOKEN_DURATION=24h
    ```
    test.env
    ```
    ENVIRONMENT=testing
    DB_DRIVER=postgres
    DB_USER=dev
    DB_NAME=mln_rms_test
    DB_HOST=localhost
    DB_PASSWORD=secret
    DB_PORT=5432
    GRPC_PORT=9091
    DB_SOURCE=${DB_DRIVER}://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}?sslmode=disable
    ```
* Run the following command to initialize the database, run the migrations, and generate the necessary proto and sql files: \
* ```
    make init
   ```
* This command will install the required dependencies, create the necessary database tables, and run the database migrations. It will also generate the proto and sql files using `sqlc` and `buf.build`. \
Note: Ensure that `sqlc`, `golang-migrate/migrate`, `buf.build`, and PostgreSQL are installed on your system before running this command.
    * `sqlc`: used to generate Go code from SQL statements
    * `golang-migrate/migrate`: used to apply database migrations
    * `buf.build`: used to generate protobuf files
    * PostgreSQL: used as the project's database management system.
* 


# **Testing**

To run the tests for the `mln_rms_api` project, follow these steps:



1. Ensure that you have the project dependencies installed. See the[ Installation](#installation) section for instructions on how to install them.
2. Start the test database server by running the following command:
* ```
    make start-test-db
    ```
3. Run the tests by running the following command:
* ```
    make test
```

This command will run all the tests defined in the project. If all tests pass, you should see a message indicating that all tests have passed. If any tests fail, you will see an error message with details on which tests failed and why.

Note that the `test.env` file is used to configure the test environment. Make sure to update it with the appropriate database credentials and ports.

It's important to note that the tests are run against a separate test database, which is initialized and migrated automatically when running the tests. This ensures that the tests do not interfere with the development or production databases.



* 


# **Running the servers**


1. Run the server by running the following command:
* ```
    make run
```


# **Implementing a new feature**



* Create a new SQL file for the feature in the `sqlc/query` folder.
* Define the request and response message types for the feature in the `pb` folder.
* Define the gRPC service for the feature in the `pb` folder and attach the new function to the service.
* Update the `Repo` interface for the feature in the `app/{module}/repo/repo.go` file to include the new function signature.
* Update the `Usecase` interface for the feature in the `app/{module}/usecase/usecase.go` file to include the new function signature.
* Update the `Factory` interface for the feature in the `app/{module}/factory/factory.go` file to include the new conversion functions and validation function.
* Create a new file in the `app/{module}/factory` folder named `factory_{module}_{feature}.go` and implement the new functions added to the `Factory` interface.
* Create a new file in the `app/{module}/repo` folder named `{feature}-repo.go` and implement the new function added to the `Repo` interface. The implementation should call the SQLC-generated function for the feature.
* Create a new file in the `app/{module}/usecase` folder named `{feature}-usecase.go` and implement the new function added to the `Usecase` interface. The implementation should convert the gRPC request to a database argument using the `NewDb{module}{feature}FromProto` function, call the corresponding function in the `Repo` interface with the database argument, and convert the repository response to a gRPC response using the `NewProto{module}{feature}FromSqlResponse` function.
* Define the new feature usecase implementation inside the `Server` struct in the `gapi/server.go` file's `NewServer` function.
* Create a new file in the `gapi` folder named `server_{feature}.go` and implement the gRPC server function for the feature. The implementation should call the corresponding usecase function with the gRPC request and return the gRPC response.


# **Testing new feature**



* Create a new file for the factory tests under `{module}/factory/{module}-{feature}_test.go`.
* Write test functions that cover all cases for the new feature conversion functions in the factory, such as `NewDb{module}{feature}FromProto` and `NewProto{module}{feature}FromSqlResponse`.
* Create a new file for the database tests under `pkg/db/sqlc/gen/{module}_test.go`.
* Write test functions that cover all cases for the new feature in the generated SQLC methods, which will be used by the repo layer.
* Create a new file for the gRPC server tests under `pkg/gapi/{module}_{feature}_rpc_test.go`.
* Write test functions that cover all cases for the new feature in the gRPC server implementation, which will call the usecase layer.
* Use the `test.env` file to configure a separate testing database and update the test function to use it instead of the development database.
* Use 
```
make test
```
to run all tests and ensure that they pass.


# **Troubleshooting**

If you encounter any issues during installation or use of the MLN RMS API, here are some steps you can take to troubleshoot:


### **1. Verify dependencies**

Make sure that all dependencies are installed and configured correctly. Check that `sqlc`, `golang-migrate/migrate`, `buf.build`, and `PostgreSQL` are installed and configured with the correct versions and credentials.


### **2. Check environment variables**

Verify that all environment variables are set correctly. Check that the database credentials and ports in `app.env` and `test.env` match the actual database configurations.


### **3. Check log files**

Check the log files for any error messages. The log files can be found in the `logs/` directory. If you see any error messages, try to identify the cause of the error and resolve it.


### **4. Check test results**

If you encounter issues while running the tests, check the test results to see which tests failed and the error messages associated with each failure. This can help identify the root cause of the issue.


### **5. Reach out for help**

If you are unable to resolve the issue on your own, reach out to the development team or community for help. You can use the project's issue tracker or forum to ask for help and provide details about the issue you are facing.

By following these steps and seeking help when needed, you can resolve most issues and continue using the MLN RMS API with minimal disruptions.


# **Conclusion**

If you encounter any issues during installation or use of the MLN RMS API, here are some steps you can take to troubleshoot:


### **1. Verify dependencies**

Make sure that all dependencies are installed and configured correctly. Check that `sqlc`, `golang-migrate/migrate`, `buf.build`, and `PostgreSQL` are installed and configured with the correct versions and credentials.


### **2. Check environment variables**

Verify that all environment variables are set correctly. Check that the database credentials and ports in `app.env` and `test.env` match the actual database configurations.


### **3. Check log files**

Check the log files for any error messages. The log files can be found in the `logs/` directory. If you see any error messages, try to identify the cause of the error and resolve it.


### **4. Check test results**

If you encounter issues while running the tests, check the test results to see which tests failed and the error messages associated with each failure. This can help identify the root cause of the issue.


### **5. Reach out for help**

If you are unable to resolve the issue on your own, reach out to the development team or community for help. You can use the project's issue tracker or forum to ask for help and provide details about the issue you are facing.

By following these steps and seeking help when needed, you can resolve most issues and continue using the MLN RMS API with minimal disruptions.
